%%%% Hybrid Power Plant calculations

  
% function [LCoE] = HybridPowerPlant_calculations(System_NumberofModules, System_NumberofKites, System_LossofLoad)

System_NumberofModules  = 44000;    % Number of solar modules in a system
System_NumberofKites    = 1;    % Number of Falcon 100 kW kites in the system
System_LossofLoad       = 8;    % Percentage of load that is lost or generated by the diesel generator


%% Design Choices

Cost.DieselPrice        = 1.2*0.92; % [EUR/Liter] cost of Diesel
Cost.CarbonTax          = 0;        % [EUR/kg] CO2 emission cost
Cost.EnergyPrice        = 0.469;    % [EUR/kWh] Energy price necessary to calculte the IRR
Cost.r                  = 0.05;     % Discount rate

System.LossofLoadCoeff  = 1;        % 0 or 1; 1 --> loss of load is covered by diesel generation, 0 --> loss of load is lost
System.OffGrid          = 1;        % 0 or 1; 1 --> yearly energy yield is calculated wrt load (off-grid), 0 --> utility-scale, everything that is generated is sold


%%%%%%%%%%%%%%%
%% Variables %%
%%%%%%%%%%%%%%%


%%% Necessary Files %%%
Load.Data   = 1000000*ones(8760,1);       % Load data
Solar.Data  = readtable('Iraq_2017.csv','PreserveVariableNames',true);   % Solar data    
Solar.Data2 = readtable('Iraq_2018.csv','PreserveVariableNames',true);   % Solar data 
Solar.Data3 = readtable('Iraq_2019.csv','PreserveVariableNames',true);   % Solar data 
Solar.Data  = [Solar.Data; Solar.Data2; Solar.Data3];
Wind.u              = ncread('Iraq.nc','u');                         % Wind data
Wind.v              = ncread('Iraq.nc','v');                         % Wind data


%%% Load %%%
% Load.Total  = 4760000;  % [Wh] Total Energy Load, equal to the energy yield of ten kites, or an military camp of 1300 personnel


%%% Location dependent variables %%%
Location.latitude   = 30.56;    % Latitude of the location positive is north
Location.longitude  = 47.25;   % Longitude of the location positive is east
Location.altitude   = 18;       % Height of the location [m]
Location.albedo     = 0.19;     % Albedo of an open field of grass is equal to 0.19


%%% Solar %%% 
%%% Module Specifiactions from the datasheet https://www.europe-solarstore.com/download/panasonic/panasonic_VBHN335SJ53_datasheet.pdf
Module.eta          = 0.200;    % Module efficiency 
Module.beta         = 0.00258;  % Temperature dependency coeffiecient
Module.Voc          = 71.00;    % Open circuit voltage [V]
Module.Isc          = 6.080;    % Short circuit current [A]
Module.Vmpp         = 59.4;     % Maximum power point voltage [V]
Module.Impp         = 5.65;     % Maximum power point current [A]
Module.n            = 144;      % Ideality factor
Module.Area         = 1.67427;  % Module area [m2]
Module.NominalPower = 335;      % Module nominal power [Wp]
Module.Lifetime     = 25;       % Module lifetime [years]
Module.Degradation  = -0.0048;  % Yearly degradation of the modules

% Module orientation
Module.Theta        = 0;        % Tilt angle [deg]  Optimal tilt angle for France is 30 degrees more or less
Module.Azimuth      = 180;      % Azimuth of the module [deg]

% Cost from https://ratedpower.com/blog/solar-farm-costs/
Cost.SolarTotal         = 700*0.92;                             % [EUR/kW] conversion Dollar to EUR = 0.92
Cost.SolarOM            = 0.005;                                % Operation and Maintenance cost [EUR/Wp]


%%% Wind %%%
% Power curve
Kite.Power_Rated    = 100000;                   % Rated power of the kite [W]
Kite.Power_Curve    = [-5000; -2500; 0; 7000; 14000; 33000; 58000; 78000; 92000; 99000; 100000; 100000; 99500; 99000; 98000; 97000];
Kite.Power_Curve    = ([Kite.Power_Curve; 0;0;0;0;0;0;0;0;0;0]);

% Cost function
Cost.GroundStation  = 100000;   % Ground stations cost [EUR], lifetime = 25 years
Cost.Tether         = 3000;     % Tether cost [EUR], lifetime = 4000 hours, half a year
Cost.KCU            = 15000;    % Kite Control Unit cost [EUR], lifetime is 25 years?
Cost.Kite           = 8000;     % Kite cost [EUR], lifetime = 4000 hours, half a year
Cost.OPEX           = 40000;    % OPEX cost [EUR]
Cost.Additional     = 24100;    % Additional cost related to cabling, grid connection etc. [EUR]


%%% Storage %%%
Cost.BatteryPrice   = 0.182;    % [EUR/Wh] source: https://www.nrel.gov/docs/fy21osti/79236.pdf, zie ook paper mihir mehta


%%% Diesel %%%
Diesel.CAPEX        = 0.600;    % [EUR/W] CAPEX cost of diesel source: https://www.lazard.com/media/1777/levelized_cost_of_energy_-_version_80.pdf



%%%%%%%%%%%%%%%%%%%%%%%
%% Load Calculations %%
%%%%%%%%%%%%%%%%%%%%%%%

% % Real-life Load Data
% Load.Data_three_years   = [Load.Data{1:8760,3}; Load.Data{1:8760,3}; Load.Data{1:8760,3}];
% for i = 1:26280
%     if isnan(Load.Data_three_years(i))
%         Load.Data_three_years(i)  = (min(Load.Data_three_years)+max(Load.Data_three_years)/2);  % Filtering out all the NaN values by filling in the average of the minimum and maximum value
%     end
% end
% Load.RealData   = Load.Total/(sum(Load.Data_three_years/3)) * Load.Data_three_years(1:8760);
% 
% 
% % Theoretical Load Data
% t                   = linspace(0,365,365*24);
% Load.Summer         = zeros(8760,1);
% Load.Winter         = zeros(8760,1);
% Load.A              = zeros(8760,1);
% Load.Theoretical    = zeros(8760,1);
% for i = 1:length(t)
% Load.Summer(i) = 0.03703-0.00328*mod(24*t(i),24)+0.00165*mod(24*t(i),24)^2 ...
%     -6.56562E-4*mod(24*t(i),24)^3+1.51959E-4*mod(24*t(i),24)^4- ...
%     1.86866E-5*mod(24*t(i),24)^5+1.28914E-6*mod(24*t(i),24)^6 ...
%     -5.05204E-8*mod(24*t(i),24)^7+1.05386E-9*mod(24*t(i),24)^8 ...
%     -9.11103E-12*mod(24*t(i),24)^9; % Electricity demand summer
% Load.Winter(i) = 0.03786-0.00119*mod(24*t(i),24)-5.42344E-4*mod(24*t(i),24)^2 ...
%     +1.48952E-4*mod(24*t(i),24)^3+2.30544E-5*mod(24*t(i),24)^4- ...
%     8.29175E-6*mod(24*t(i),24)^5+8.41687E-7*mod(24*t(i),24)^6 ...
%     -4.0464E-8*mod(24*t(i),24)^7+9.50205E-10*mod(24*t(i),24)^8 ...
%     -8.7815E-12*mod(24*t(i),24)^9; % Electricity demand winter
% Load.A(i)   = (1+0.075*cos(4*pi*(t(i)-217)/365))*(1-0.045*cos(2*pi*(t(i)-217)/365));
% Load.Theoretical(i) =  Load.Total/365*(Load.Summer(i)*(0.5+0.5*cos(2*pi*(t(i)-172)/365)) ...
%     +Load.Winter(i)*(0.5-0.5*cos(2*pi*(t(i)-172)/365)))*Load.A(i);
% end
% clear t
% clear i


% Load Data Military Camp
Load.MilitaryCamp = 1000000*ones(8760,1);


% Daily energy demand
Load.MilitaryCamp_Daily = zeros(365,1);
Load.MilitaryCamp_Daily(1,1) = sum(Load.MilitaryCamp(1:24,1));
for i = 1:364
    Load.MilitaryCamp_Daily(i+1,1) = sum(Load.MilitaryCamp(24*i+1:24*i+24,1));
end








%%%%%%%%%%%%%%%%%%%%%%%%
%% Solar Calculations %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%% Step 1: Module Specifications 
%%%

Module.SF           = 1;                        % Shading factor
Module.SVF          = (1+cos(Module.Theta))/2;  % Sky view factor 

System.Area         = System_NumberofModules*Module.Area;   % Area covered in solar modules [m2]


%%% Step 2: Acquiring data from NREL 
%%%

Time.year       = Solar.Data{:,1};   
Time.month      = Solar.Data{:,2};
Time.day        = Solar.Data{:,3};
Time.hour       = Solar.Data{:,4};
Time.minute     = Solar.Data{:,5};
Time.second     = zeros(length(Time.year),1);
Time.UTCOffset  = 3*ones(length(Time.year),1);

Irradiance.DHI  = Solar.Data{:,7};   % Diffuse horizontal irradiation [W/m2]
Irradiance.DNI  = Solar.Data{:,8};   % Direct normal irradiation      [W/m2]
Irradiance.GHI  = Solar.Data{:,9};   % Global horizontal irradiation  [W/m2]

Temperature.ambient = Solar.Data{:,6};    % Ambient temperature [C]
WindSpeed.data      = Solar.Data{:,10};   % WindSpeed [m/s]

[Sun.azimuth, Sun.height] = pvl_spa(Time, Location);    % Sandia toolbox function to calculate the sun Azimuth and Zenith angle [deg]

Sun.azimuth_rad = Sun.azimuth*pi/180;           % Conversion of the sun azimuth with the addition of 180 degrees
Sun.height_rad  = max(0, Sun.height*pi/180);    % Conversion of the sun height to radians
Sun.zenith      = 90-Sun.height;
Sun.zenith_rad  = Sun.zenith*pi/180;

Module.AOI      = pvl_getaoi(Module.Theta, Module.Azimuth, Sun.zenith, Sun.azimuth);
Module.AOI_rad  = max(0,cos(Module.AOI*pi/180));


%%% Step 3: Conversion from DHI,DNI,GHI to Dir,Dif,Ref Irradiance
%%% calculations 

Irradiance.Dir   = Irradiance.DNI.*Module.AOI_rad*Module.SF;        % Direct irradiance     [W/m2]
Irradiance.Dif   = Module.SVF.*Irradiance.DHI;                      % Diffuse irradiance    [W/m2]
Irradiance.Ref   = Irradiance.GHI*Location.albedo*(1-Module.SVF);   % Reflected irradiance  [W/m2]

Irradiance.Total = Irradiance.Dir + Irradiance.Dif + Irradiance.Ref; 

% Daily Irradiance
Irradiance.Daily = zeros(length(Irradiance.Total)/24,1);
Irradiance.Daily(1,1) = sum(Irradiance.Total(1:24,1));
for i = 1:length(Irradiance.Total)/24 -1
    Irradiance.Daily(i+1,1) = sum(Irradiance.Total(24*i+1:24*i+24,1));
end

% Monthly Irradiance
Irradiance.Monthly = zeros(12,1);
Irradiance.Monthly(1,1) = sum(Irradiance.Daily(1:35,1));
for i = 1:11
    Irradiance.Monthly(i+1,1) = sum(Irradiance.Daily(30*i:30*i+35,1));
end

Irradiance.ESH = sum(Irradiance.GHI)/(1000*365*3);


%%% Step 4: Temperature Dependency using ambient temperature and wind speed
%%% 

WindSpeed.measured_height   = 13;       % Measure height of the weather station [m]
Module.placement_height     = 5;        % Height of the solar modules [m]
WindSpeed.roughness_length  = 0.01;     % Surface rougness length [m] = 0.01 for very open landscape     
Temperature.NOCT            = 45;       % Temperature at Normal Operating Conditions [C]

Module.windSpeed    = WindSpeed.data*log(Module.placement_height/WindSpeed.roughness_length)/log(WindSpeed.measured_height/WindSpeed.roughness_length); % WindSpeed at module height [m] using the log law
Module.temperature  = Temperature.ambient + (Temperature.NOCT-3-20)/800.*Irradiance.Total.*(9.5./(5.7+3.8.*Module.windSpeed))*(1-Module.eta/0.9);       % Module temperature [C] Rack mounted

Module.eta_fac_Temp_dep = 1-Module.beta.*(Module.temperature-25);   % Factor for the temperature dependency


%%% Step 5: Irradiance Dependency 
%%%

Constants.k_b   = 1.3807*10^-23;    % Boltzmann constant
Constants.q     = 1.602*10^-19;     % Electron charge

Module.FF       = Module.eta*1000*Module.Area/(Module.Voc*Module.Isc);  % Fill factor of the module

Module.Voc_25C  = ones(length(Irradiance.Total),1);     % Calculating the open circuit voltage dependent on the different irradiance levels
for i = 1:length(Irradiance.Total)
    if Irradiance.Total(i,1) == 0
        Module.Voc_25C(i,1) = Module.Voc;
    else
        Module.Voc_25C(i,1) = Module.Voc + Module.n*Constants.k_b*298/Constants.q.*log(Irradiance.Total(i,1)/1000);
    end
end

Module.Isc_25C  = Module.Isc.*Irradiance.Total/1000;            % Calculating the short circuit current dependent on the different irradiance levels
Module.Pmpp_25C = Module.FF.*Module.Voc_25C.*Module.Isc_25C;    % The new power produced on the different irradiance levels

Module.eta_25C  = ones(length(Irradiance.Total),1);
for i = 1:length(Irradiance.Total)
    if Irradiance.Total(i,1) == 0
        Module.eta_25C(i,1) = 0;
    else 
        Module.eta_25C(i,1) = Module.Pmpp_25C(i,1)./(Irradiance.Total(i,1)*Module.Area);
    end
end


%%% Step 6: Power output of the PV module before BoS
%%%


Module.eta_TM_GM    = Module.eta_25C.*Module.eta_fac_Temp_dep;  % Final efficiency of the module 

SolarPower.Hourly    = Module.eta_TM_GM.*Irradiance.Total*Module.Area;   % Hourly Power produced by the module with efficiency depending on temp. and light intensity [W]
SolarPower.Daily     = zeros(length(Irradiance.Total)/24,1);
SolarPower.Daily(1,1)    = sum(SolarPower.Hourly(1:24),1);
for i = 1:length(Irradiance.Total)/24-1
    SolarPower.Daily(i+1,1) = sum(SolarPower.Hourly(24*i+1:24*i+24,1));
end

SolarPower.Hourly_constant_eta   = Module.eta*Irradiance.Total*Module.Area;  % Hourly Power produced with constant efficiency
SolarPower.Dependency_Hourly     = SolarPower.Hourly - SolarPower.Hourly_constant_eta;

SolarPower.Dependency_Daily      = zeros(length(Irradiance.Total)/24,1);
SolarPower.Dependency_Daily(1,1) = sum(SolarPower.Dependency_Hourly(1:24),1);
for i = 1:length(Irradiance.Total)/24-1
    SolarPower.Dependency_Daily(i+1,1) = sum(SolarPower.Dependency_Hourly(24*i+1:24*i+24,1));
end


%%% Step 7: Energy production
%%%


%  System efficiency
Module.degradation  = 0.880;    % Average degradation of the models over their lifetime
System.wiring       = 0.985;    % Wiring Ohmic efficiency
System.mismatch     = 0.993;    % Module Mismatch efficiency
%System.inverter     = 0.965;    % Inverter efficiency

System.Efficiency   = Module.degradation*System.wiring*System.mismatch;     %*System.inverter; % Overall system efficiency
System.NominalPower = Module.NominalPower * System_NumberofModules /1000;   % System nominal power [kWp] 

SolarEnergy.Hourly  = SolarPower.Hourly *System.Efficiency * System_NumberofModules /1000;         % System energy produced hourly [kWh]


% Daily power produced
SolarEnergy.Daily = zeros(length(Irradiance.Total)/24,1);
SolarEnergy.Daily(1,1) = sum(SolarEnergy.Hourly(1:24,1));
for i = 1:length(Irradiance.Total)/24-1
    SolarEnergy.Daily(i+1,1) = sum(SolarEnergy.Hourly(24*i+1:24*i+24,1));
end

SolarEnergy.Yearly_avg  = sum(SolarEnergy.Hourly)/(3*1000);              % Average Annual Energy Production [MWh]
SolarEnergy.Lifetime    = SolarEnergy.Yearly_avg*Module.Lifetime;    % Lifetime energy yield [MWh]

System.CapacityFactor   =   SolarEnergy.Yearly_avg*1000 / (System.NominalPower*8760);





%%% Step 8: Economic KPI calculations
%%%

Cost.SolarSyst_total    = Cost.SolarTotal*System.NominalPower;  % Investment cost

% Yearly Energy Production with yearly module degradation
SolarEnergy.Yearly   = ones(Module.Lifetime,1);
for i = 1:Module.Lifetime
    SolarEnergy.Yearly(i) = SolarEnergy.Yearly_avg*1000 * (1+Module.Degradation*(i-1))/Module.degradation;
end

% Denominator calculation of the LCoE
SolarEnergy.LCoE = ones(Module.Lifetime,1);
for i = 1:Module.Lifetime
    SolarEnergy.LCoE(i) = SolarEnergy.Yearly(i) / (1+Cost.r)^i;
end

% Numerator calculation
Cost.SolarYearly = ones(Module.Lifetime+1,1);
Cost.SolarYearly(1,1) = Cost.SolarSyst_total;
for i = 2:26
    Cost.SolarYearly(i) = Cost.SolarOM*System.NominalPower*1000 / (1+Cost.r)^(i-1);
end

Cost.SolarLCoE = sum(Cost.SolarYearly) / sum(SolarEnergy.LCoE);







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%          Wind Calculations          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Loading in the wind speed data taken from ERA5
%%%

Wind.Speed = sqrt(Wind.u(1,1,:).^2+Wind.v(1,1,:).^2); % The wind speed is a combination of the u and v component of the downloaded data
Wind.Speed = reshape(Wind.Speed,[],1);  % Reshaping of the 1x1xN matrix to make it a vector


%%% Fitting of the curve from Excel model
%%%


Wind.Fit_ws     = linspace(0,25,26)';   % Wind speeds for the fit

Wind.Fit1       = 2500*Wind.Fit_ws-5000;                                    % For wind speed [0-2] m/s
Wind.Fit2       = fit(Wind.Fit_ws(3:12),Kite.Power_Curve(3:12),'poly5');    % For wind speed [2-10] m/s
Wind.Fit3       = Kite.Power_Rated;                                         % For wind speed [10-11] m/s
Wind.Fit4       = -500*Wind.Fit_ws+105500;                                  % For wind speed [11-13] m/s
Wind.Fit5       = -2000*Wind.Fit_ws+126000;                                 % For wind speed [13-15] m/s

Wind.Coeffs     = coeffvalues(Wind.Fit2);                                   % Coefficients


%%% How does the power curve look like now 
%%%


Wind.Test1 = zeros(26,1);
for i = 1:26
    if  i <= 3
        Wind.Test1(i) = 2500*(i-1)-5000;
    elseif 3 <= i && i <= 10
        Wind.Test1(i) = polyval(Wind.Coeffs,(i-1));
    elseif 10 <= i && i <= 12
        Wind.Test1(i) = Kite.Power_Rated;
    elseif 12 <= i && i <= 14
        Wind.Test1(i) = -500*(i-1)+105500;
    elseif 14 <= i && i <= 26                                   % Cut off wind speed is 25 m/s
        Wind.Test1(i) = -1000*(i-1)+112000;
    else
        Wind.Test1(i) = 0;
    end
end


%%% Power production by the kite
%%%


Kite.Power  = zeros(length(Wind.Speed),1);                    % [W]
for i = 1:length(Wind.Speed)
    if  Wind.Speed(i) <= 3
        Kite.Power(i) = 2500*Wind.Speed(i)-5000;
    elseif 3 <= Wind.Speed(i) && Wind.Speed(i) <= 10
        Kite.Power(i) = polyval(Wind.Coeffs,Wind.Speed(i));
    elseif 10 <= Wind.Speed(i) && Wind.Speed(i) <= 12
        Kite.Power(i) = Kite.Power_Rated;
    elseif 12 <= Wind.Speed(i) && Wind.Speed(i) <= 14
        Kite.Power(i) = -500*Wind.Speed(i)+105500;
    elseif 14 <= Wind.Speed(i) && Wind.Speed(i) <= 26           % cut off wind speed is 25 m/s
        Kite.Power(i) = -1000*Wind.Speed(i)+112000;
    else
        Kite.Power(i) = 0;
    end
end


Kite.CapacityFactor = sum(Kite.Power)/(Kite.Power_Rated*8760*3);


% Daily power produced
Kite.EnergyDaily = zeros(length(Wind.Speed)/24,1);
Kite.EnergyDaily(1,1) = sum(System_NumberofKites*Kite.Power(1:24,1));
for i = 1:length(Wind.Speed)/24-1
    Kite.EnergyDaily(i+1,1) = sum(System_NumberofKites*Kite.Power(24*i+1:24*i+24,1));
end




%%% Cost
%%%


% Yearly Energy Production with yearly module degradation
KiteEnergy.Yearly   = ones(25,1);
for i = 1:25
    KiteEnergy.Yearly(i) = sum(System_NumberofKites*Kite.Power)/(3*1000);    % [kWh]
end

% Denominator calculation of the LCoE
KiteEnergy.LCoE = ones(25,1);
for i = 1:25
    KiteEnergy.LCoE(i) = KiteEnergy.Yearly(i) / (1+Cost.r)^i;
end


% Numerator calculation
Cost.WindYearly = ones(26,1);
Cost.WindYearly(1,1) = System_NumberofKites*(Cost.GroundStation+Cost.KCU+Cost.Kite+Cost.Tether+Cost.Additional);
Cost.WindYearly(2,1) = System_NumberofKites*(Cost.OPEX + Cost.Kite + Cost.Tether) / (1+Cost.r);
for i = 3:25
    Cost.WindYearly(i) = System_NumberofKites*(Cost.OPEX + 2*(Cost.Kite+Cost.Tether)) / (1+Cost.r)^(i-1);
end
Cost.WindYearly(26,1) = System_NumberofKites*Cost.OPEX / (1+Cost.r)^25;

Cost.WindLCoE = sum(Cost.WindYearly) / sum(KiteEnergy.LCoE);






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Hybrid Power Plant Calculations   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

System.Generation   = (System_NumberofModules* SolarPower.Hourly *System.Efficiency ...
                        + System_NumberofKites*Kite.Power);  
Battery.Mismatch    = System.Generation-[Load.MilitaryCamp; Load.MilitaryCamp; Load.MilitaryCamp];


Battery.Size        = 0;                % is only valid of the NumberofModules is significantly high
Battery.Minimum     = 0.1*Battery.Size;
Battery.Maximum     = Battery.Size;

Battery.StateofCharge       = ones(26280,1);    % Vector set-up
Battery.StateofCharge(1,1)  = 1*Battery.Size;   % [Wh] Initial charge of the battery, doesn't matter
for i = 1:26280
    if Battery.StateofCharge(i)+Battery.Mismatch(i) <= Battery.Size 
        if Battery.Mismatch(i) > 0 
            Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i);
        else 
            Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i)/0.9;    % Addition of the roundtrip efficiency of 90%
        end
    else
        if Battery.Mismatch(i) > 0
            Battery.StateofCharge(i+1) = Battery.Size;
        else 
            Battery.StateofCharge(i+1) = Battery.Size+Battery.Mismatch(i)/0.9;
        end       
    end
end

Battery.Size        = -10/9*prctile(Battery.StateofCharge,System_LossofLoad);  % The loop above, gives the new battery size so load is always delivered
Battery.Minimum     = 0.1*Battery.Size;
Battery.Maximum     = Battery.Size;


Battery.StateofCharge       = ones(26280,1);    % Vector set-up
Battery.StateofCharge(1,1)  = 1*Battery.Size;   % [W] Initial charge of the battery, doesn't matter too much
for i = 1:26280
    if Battery.StateofCharge(i)+Battery.Mismatch(i) <= Battery.Size 
        if Battery.Mismatch(i) > 0 
            Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i);
        else
            Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i)/0.9;    % Addition of the roundtrip efficiency of 90%
        end
    else
        if Battery.Mismatch(i) > 0
            Battery.StateofCharge(i+1) = Battery.Size;
        else 
            Battery.StateofCharge(i+1) = Battery.Size+Battery.Mismatch(i)/0.9;
        end       
    end
end

Battery.Power = max(abs(Battery.Mismatch));

if System.LossofLoadCoeff == 1

    Diesel.Necessary = zeros(26280,1);
    for i = 1:26280
        if  Battery.StateofCharge(i+1) < Battery.Minimum && Battery.Mismatch(i) < 0 
            Diesel.Necessary(i) = -Battery.Mismatch(i);                     % [Wh]
        else
            Diesel.Necessary(i) = 0;
        end
    end
    
    
    System.GenerationwithDiesel = System.Generation + Diesel.Necessary;
    Battery.Mismatch            = System.GenerationwithDiesel-[Load.MilitaryCamp; Load.MilitaryCamp; Load.MilitaryCamp];
    
    
    for i = 1:26280
        if Battery.StateofCharge(i)+Battery.Mismatch(i) <= Battery.Size 
            if Battery.Mismatch(i) > 0 
                Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i);
            else 
                Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i)/0.9;    % Addition of the roundtrip efficiency of 90%
            end
        else
            if Battery.Mismatch(i) > 0
                Battery.StateofCharge(i+1) = Battery.Size;
            else 
                Battery.StateofCharge(i+1) = Battery.Size+Battery.Mismatch(i)/0.9;
            end       
        end
    end
    
    
    
    Battery.Size        = 10/9*(-min(Battery.StateofCharge)+Battery.Size);  % The loop above, gives the new battery size so load is always delivered
    Battery.Minimum     = 0.1*Battery.Size;
    Battery.Maximum     = Battery.Size;
    
    
    Battery.StateofCharge       = ones(26280,1);    % Vector set-up
    Battery.StateofCharge(1,1)  = 1*Battery.Size;   % [W] Initial charge of the battery, doesn't matter too much
    for i = 1:26280
        if Battery.StateofCharge(i)+Battery.Mismatch(i) <= Battery.Size 
            if Battery.Mismatch(i) > 0 
                Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i);
            else
                Battery.StateofCharge(i+1) = Battery.StateofCharge(i)+Battery.Mismatch(i)/0.9;    % Addition of the roundtrip efficiency of 90%
            end
        else
            if Battery.Mismatch(i) > 0
                Battery.StateofCharge(i+1) = Battery.Size;
            else 
                Battery.StateofCharge(i+1) = Battery.Size+Battery.Mismatch(i)/0.9;
            end       
        end
    end




elseif System.LossofLoadCoeff == 0

    Diesel.Necessary = zeros(26280,1);
    
end


% Battery Cost
Cost.Battery        = zeros(26,1);
Cost.Battery(1,1)   = Cost.BatteryPrice*Battery.Size;       % [EUR]
Cost.Battery(11,1)  = Cost.Battery(1,1) / (1+Cost.r)^10;    % three batteries necessary over the lifetime of the project
Cost.Battery(21,1)  = Cost.Battery(1,1) / (1+Cost.r)^20;


% Diesel Generation Cost
Diesel.GeneratorSize    = System.LossofLoadCoeff * max(Diesel.Necessary);
Cost.Generator          = Diesel.GeneratorSize * Diesel.CAPEX;                  % [EUR]
Cost.DieselGeneration   = (0.4*Cost.DieselPrice + 1.04*Cost.CarbonTax)/1000;    % [EUR/Wh]
Cost.Diesel             = Cost.DieselGeneration * sum(Diesel.Necessary(8761:17520)); %System_LossofLoad/100 * Load.Total; % [EUR]

Cost.DieselYearly = ones(26,1);
Cost.DieselYearly(1,1) = (Cost.Diesel) + Cost.Generator;
for i = 2:25
    Cost.DieselYearly(i) = (Cost.Diesel) / (1+Cost.r)^(i-1);
end
Cost.DieselYearly(26,1) = 0 / (1+Cost.r)^25;




if System.OffGrid == 0
    % For Grid-Connected applications:
    % Denominator calculation of the LCoE
    % Yearly Energy Production with yearly module degradation

    Energy.HPPYearly   = ones(25,1);
    for i = 1:25
        Energy.HPPYearly(i) =  ( sum(System_NumberofKites*Kite.Power) +  sum(System_NumberofModules* SolarPower.Hourly *System.Efficiency) *(1+Module.Degradation*(i-1))/Module.degradation  + sum(Diesel.Necessary(8761:17520))) /1000;   % [kWh]
    end
    Energy.HPPLCoE = ones(25,1);
    for i = 1:25
        Energy.HPPLCoE(i) = Energy.HPPYearly(i) / (1+Cost.r)^i;             % [kWh]
    end

elseif System.OffGrid == 1 
    % Off-grid applications:
    % Only the energy used by load is considered
    % Yearly Energy Production use looking at the load case

    Energy.HPPYearly   = ones(25,1);
    for i = 1:25
        Energy.HPPYearly(i) =  (sum(Load.MilitaryCamp)) /1000;    % [kWh]
    end
    Energy.HPPLCoE = ones(25,1);
    for i = 1:25
        Energy.HPPLCoE(i) = Energy.HPPYearly(i) / (1+Cost.r)^i;   % [kWh]
    end
end



% Numerator Calculation
Cost.HPPYearly  = (Cost.SolarYearly + Cost.WindYearly + Cost.Battery + System.LossofLoadCoeff * Cost.DieselYearly); 

LCoE = sum(Cost.HPPYearly) / sum(Energy.HPPLCoE) * 1000;    % [EUR/MWh]


Diesel.Percentage = sum(Diesel.Necessary)/(3*8760*1000000);


%%%%%%
% Internal Rate of Return                              
% Solar
Cost.IRR_SolarYearly = ones(Module.Lifetime+1,1);
Cost.IRR_SolarYearly(1,1) = Cost.SolarSyst_total;
for i = 2:26
    Cost.SolarYearly(i) = Cost.SolarOM*System.NominalPower*1000;
end

% Wind
Cost.IRR_WindYearly = ones(26,1);
Cost.IRR_WindYearly(1,1) = System_NumberofKites*(Cost.GroundStation+Cost.KCU+Cost.Kite+Cost.Tether+Cost.Additional);
Cost.IRR_WindYearly(2,1) = System_NumberofKites*(Cost.OPEX + Cost.Kite + Cost.Tether);
for i = 3:25
    Cost.IRR_WindYearly(i) = System_NumberofKites*(Cost.OPEX + 2*(Cost.Kite+Cost.Tether));
end
Cost.IRR_WindYearly(26,1) = System_NumberofKites*Cost.OPEX;

% Storage
Cost.IRR_Battery        = zeros(26,1);
Cost.IRR_Battery(1,1)   = Cost.BatteryPrice*Battery.Size;                   
Cost.IRR_Battery(11,1)  = Cost.Battery(1,1);    
Cost.IRR_Battery(21,1)  = Cost.Battery(1,1);

% Diesel
Cost.IRR_Diesel         = zeros(26,1);
Cost.IRR_Diesel(1,1)    = (Cost.Diesel) + Cost.Generator;
for i = 2:25
    Cost.IRR_Diesel(i)  = (Cost.Diesel);
end
Cost.IRR_Diesel(26,1) = 0;

% Total
Cost.InitialInvestment  = Cost.IRR_SolarYearly(1,1) + Cost.IRR_WindYearly(1,1) + Cost.IRR_Battery(1,1) + Cost.IRR_Diesel(1,1);
Cost.IRR_HPPYearly      = Cost.IRR_SolarYearly + Cost.IRR_WindYearly + Cost.IRR_Battery + Cost.IRR_Diesel;


Cost.SavingsYearly      = Energy.HPPYearly*Cost.EnergyPrice;                % [EUR]
Cost.NetCashFlow        = Cost.SavingsYearly-Cost.IRR_HPPYearly(2:26);
Cost.IRR                = irr([-Cost.InitialInvestment Cost.NetCashFlow']); % Internal Rate of Return


%%%%%%%%%
%Net Present Value
Cost.NPV_CashFlow = ones(25,1);
for i = 1:25
    Cost.NPV_CashFlow(i,1) = Cost.NetCashFlow(i)/(1+Cost.r)^i;
end

Cost.NPV     = -Cost.InitialInvestment+sum(Cost.NPV_CashFlow); % Net Present Value



% Daily power produced
HPP.DailyEnergy = zeros(365,1);
HPP.DailyEnergy(1,1) = sum(System.Generation(1:24,1));
for i = 1:364
    HPP.DailyEnergy(i+1,1) = sum(System.Generation(24*i+1:24*i+24,1));
end

clear i



% % Plotting the State of Charge of the battery throughout three years,
% % variable load
% figure
% plot(Battery.StateofCharge/1000000)
% xlim([0 26280])
% hold on
% yline(Battery.Minimum/1000000,'r')
% yline(Battery.Maximum/1000000,'r')
% yline(0,'k')
% xticks([0 4380 8760 13140 17520 21900 26280])
% xticklabels({'0' '0.5' '1' '1.5' '2' '2.5' '3'})
% xlabel('Time [years]')
% ylabel('Energy [MWh]')
% grid on
% title('Battery Capacity over a period of three years')





disp('Solar Power')
disp(System.NominalPower/1000)
disp('Kite Power')
disp(System_NumberofKites/10)
disp('Battery Capacity')
disp(Battery.Size/1000000)
disp('Diesel Percentage')
disp(Diesel.Percentage)
disp('LCoE')
disp(LCoE)



% end

















